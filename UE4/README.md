# Unreal Engine 4

## Terminology

[[1]](#-материалы)
* **Projects** - Проект представляет собой автономный блок , который содержит все содержимое и код , которые составляют индивидуальную игру и совпадает с набором каталогов на вашем диске. 
* **Objects** - Базовые строительные блоки в Unreal Engine называются объектами и содержат много важных функций «под капотом» для ваших игровых активов. Почти все в Unreal Engine 4 наследует (или получает некоторую функциональность) от объекта. В C++ **UObject** это базовый класс всех объектов; он реализует такие функции, как сборка мусора, поддержка метаданных ( UProperty) для предоставления переменных в Unreal Editor и сериализация для загрузки и сохранения. 
* **Classes** - Класс определяет поведение и свойства конкретного актера (Actor) или предмета(Object), используемого в создании Unreal Engine игры. Классы являются иерархическими, то есть класс наследует информацию от своих родительских классов (классы, из которых он был получен или «подклассифицирован») и передает эту информацию своим дочерним элементам. Классы могут быть созданы в коде C++ или в Blueprints.
* **Actors** - Актер является любой объект, который может быть помещен в уровень. Актеры - это общий класс, который поддерживает трехмерные преобразования, такие как перемещение, вращение и масштабирование. Актеры могут быть созданы (spawn) и уничтожены с помощью кода игрового процесса (C++ или Blueprints). В C++ **AActor** является базовым классом всех актеров.  
Существует несколько различных типов актеров, например: StaticMeshActor, CameraActor и PlayerStartActor.
* **Components** - Компонент представляет собой часть функциональных возможностей, которые могут быть добавлены в качестве актера. Компоненты не могут существовать сами по себе, однако, при добавлении в Actor, Actor будет иметь доступ и использовать функции, предоставляемые Компонентом.  
Например, компонент Spot Light позволит вашему актеру излучать свет, похожий на прожектор, компонент Rotating Movement заставит вашего актера вращаться вокруг, или аудио компонент позволит вашему актеру воспроизводить звуки.
* **Pawns** - Пешки являются подклассом актера и служат в качестве аватара или персонажа в игре, например персонажей в игре. Пешки могут управляться игроком или ИИ игры в виде неигровых персонажей (NPC).  
Когда пешка контролируется человеком или ИИ-игроком, она считается одержимой (*Possessed*). И наоборот, когда Пешка не контролируется человеком или ИИ-игроком, она рассматривается как Бесхозная (*Unpossessed*).
* **Characters** - является подклассом Pawn актера , который предназначен для использования в качестве игрового персонажа. Подкласс персонажа включает в себя настройку столкновения, привязки ввода для движения двуногих и дополнительный код для движения, контролируемого игроком.
* **PlayerController** - Класс *PlayerController* используется для получения информации от игрока и преобразования ее во взаимодействия в игре, и в каждой игре есть хотя бы один *PlayerController*. *PlayerController* часто использует пешку или персонажа как представление игрока в игре.  
*PlayerController* также является основной точкой сетевого взаимодействия для многопользовательских игр. Во время многопользовательской игры сервер имеет один экземпляр *PlayerController* для каждого игрока в игре, поскольку он должен иметь возможность выполнять вызовы сетевых функций для каждого игрока. У каждого клиента есть только *PlayerController*, соответствующий его игроку, и он может использовать только *PlayerController* для связи с сервером.
* **AIController** - Подобно тому, как *PlayerController* обладает *Pawn* в качестве представления игрока в игре, *AIController* обладает *Pawn* для представления неигрового персонажа (NPC) в игре. По умолчанию у Пешек и Персонажей будет базовый *AIController*, если только они не принадлежат *PlayerController* или им не запрещено создавать *AIController* для себя.
* **Brushes** - Кисть является актером, который описывает 3D объем , который помещается в уровне , с тем чтобы определить геометрию уровня (*referred to as BSPs*) и объемы игрового процесса. Обычно вы используете *BSP Brushes* для создания прототипа или блокировки ваших уровней для тестирования игрового процесса.  
*Volumes*, с другой стороны, имеют несколько применений в зависимости от связанных с ними эффектов, таких как: *Blocking Volumes* (которые невидимы и используются для предотвращения прохождения через них действующих лиц), *Pain Causing Volumes* (которые со временем наносят ущерб любому действующему субъекту, перекрывающему его) ) или *Trigger Volumes* (которые используются как способ вызывать события, когда субъект входит или выходит из них).
* **Levels** - Уровень представляет собой определенный пользователем область геймплея. Уровни создаются, просматриваются и изменяются главным образом путем размещения, преобразования и редактирования свойств содержащихся в нем действующих лиц. В редакторе Unreal каждый уровень сохраняется в виде отдельного файла .umap, поэтому вы иногда будете видеть их как карты.
* **World** - World содержит список уровней, которые загружаются. Он обрабатывает потоки уровней и порождение (*spawning*) динамических актеров.  
Прямое взаимодействие с миром необязательно, но оно помогает обеспечить конкретную точку отсчета в структуре игры (т.е. Прямое упоминание мира означает, что вы не говорите об уровнях, картах или игре).
* **GameModes** - Класс *GameMode* отвечает за установление правил игры, в которую играют. Правила могут включать, как игроки присоединяются к игре, может ли игра быть приостановлена, и переходы уровня, а также любое специфическое для игры поведение, такое как условия победы.  
Вы можете установить *GameMode* по умолчанию в настройках проекта, но можете переопределить его для каждого уровня. Независимо от того, как вы решили реализовать *GameMode*, на каждом уровне всегда присутствует только один *GameMode*. В многопользовательской игре *GameMode* существует только на сервере, и правила реплицируются (отправляются) каждому из подключенных клиентов.
* **GameStates** - *GameState* содержит информацию , которую вы хотите реплицировать к каждому клиенту в игре, или более просто это «The State of the Game'» для всех , кто связан (for everyone connected).  
Он часто содержит информацию об игровом счете, независимо от того, начался матч или нет, сколько искусственного интеллекта появилось в зависимости от количества игроков в мире, и другую информацию, специфичную для игры.  
Для игр с многопользовательским режимом существует один экземпляр *GameState* на компьютере каждого игрока, причем экземпляр сервера является авторитетным (или тот, от которого клиенты получают обновленную информацию).
* **PlayerStates** - *PlayerState* является состоянием участника игры, такими как человеческий игрок или бот, который имитирующий игроком. Неигровой ИИ, существующий как часть игрового мира, не имеет *PlayerState*.  
Примерные данные, которые будут уместны в *PlayerState*, включают имя или счет игрока, его текущий уровень или состояние здоровья, а также то, несут ли они в настоящее время флаг в игре *Capture the Flag*.  
В многопользовательских играх *PlayerStates* для всех игроков существуют на всех компьютерах (в отличие от *PlayerControllers*) и могут реплицировать данные с сервера на клиент для синхронизации данных.

## Материалы

1. [https://docs.unrealengine.com/en-US/GettingStarted/Terminology/index.html](https://docs.unrealengine.com/en-US/GettingStarted/Terminology/index.html)