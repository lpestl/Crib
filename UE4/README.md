# Unreal Engine 4

## Terminology

[[1]](#-материалы)
* **Projects** - Проект представляет собой автономный блок , который содержит все содержимое и код , которые составляют индивидуальную игру и совпадает с набором каталогов на вашем диске. 
* **Objects** - Базовые строительные блоки в Unreal Engine называются объектами и содержат много важных функций «под капотом» для ваших игровых активов. Почти все в Unreal Engine 4 наследует (или получает некоторую функциональность) от объекта. В C++ **UObject** это базовый класс всех объектов; он реализует такие функции, как сборка мусора, поддержка метаданных ( UProperty) для предоставления переменных в Unreal Editor и сериализация для загрузки и сохранения. 
* **Classes** - Класс определяет поведение и свойства конкретного актера (Actor) или предмета(Object), используемого в создании Unreal Engine игры. Классы являются иерархическими, то есть класс наследует информацию от своих родительских классов (классы, из которых он был получен или «подклассифицирован») и передает эту информацию своим дочерним элементам. Классы могут быть созданы в коде C++ или в Blueprints.
* **Actors** - Актер является любой объект, который может быть помещен в уровень. Актеры - это общий класс, который поддерживает трехмерные преобразования, такие как перемещение, вращение и масштабирование. Актеры могут быть созданы (spawn) и уничтожены с помощью кода игрового процесса (C++ или Blueprints). В C++ **AActor** является базовым классом всех актеров.  
Существует несколько различных типов актеров, например: StaticMeshActor, CameraActor и PlayerStartActor.
* **Components** - Компонент представляет собой часть функциональных возможностей, которые могут быть добавлены в качестве актера. Компоненты не могут существовать сами по себе, однако, при добавлении в Actor, Actor будет иметь доступ и использовать функции, предоставляемые Компонентом.  
Например, компонент Spot Light позволит вашему актеру излучать свет, похожий на прожектор, компонент Rotating Movement заставит вашего актера вращаться вокруг, или аудио компонент позволит вашему актеру воспроизводить звуки.
* **Pawns** - Пешки являются подклассом актера и служат в качестве аватара или персонажа в игре, например персонажей в игре. Пешки могут управляться игроком или ИИ игры в виде неигровых персонажей (NPC).  
Когда пешка контролируется человеком или ИИ-игроком, она считается одержимой (*Possessed*). И наоборот, когда Пешка не контролируется человеком или ИИ-игроком, она рассматривается как Бесхозная (*Unpossessed*).
* **Characters** - является подклассом Pawn актера , который предназначен для использования в качестве игрового персонажа. Подкласс персонажа включает в себя настройку столкновения, привязки ввода для движения двуногих и дополнительный код для движения, контролируемого игроком.
* **PlayerController** - Класс *PlayerController* используется для получения информации от игрока и преобразования ее во взаимодействия в игре, и в каждой игре есть хотя бы один *PlayerController*. *PlayerController* часто использует пешку или персонажа как представление игрока в игре.  
*PlayerController* также является основной точкой сетевого взаимодействия для многопользовательских игр. Во время многопользовательской игры сервер имеет один экземпляр *PlayerController* для каждого игрока в игре, поскольку он должен иметь возможность выполнять вызовы сетевых функций для каждого игрока. У каждого клиента есть только *PlayerController*, соответствующий его игроку, и он может использовать только *PlayerController* для связи с сервером.
* **AIController** - Подобно тому, как *PlayerController* обладает *Pawn* в качестве представления игрока в игре, *AIController* обладает *Pawn* для представления неигрового персонажа (NPC) в игре. По умолчанию у Пешек и Персонажей будет базовый *AIController*, если только они не принадлежат *PlayerController* или им не запрещено создавать *AIController* для себя.
* **Brushes** - Кисть является актером, который описывает 3D объем , который помещается в уровне , с тем чтобы определить геометрию уровня (*referred to as BSPs*) и объемы игрового процесса. Обычно вы используете *BSP Brushes* для создания прототипа или блокировки ваших уровней для тестирования игрового процесса.  
*Volumes*, с другой стороны, имеют несколько применений в зависимости от связанных с ними эффектов, таких как: *Blocking Volumes* (которые невидимы и используются для предотвращения прохождения через них действующих лиц), *Pain Causing Volumes* (которые со временем наносят ущерб любому действующему субъекту, перекрывающему его) ) или *Trigger Volumes* (которые используются как способ вызывать события, когда субъект входит или выходит из них).
* **Levels** - Уровень представляет собой определенный пользователем область геймплея. Уровни создаются, просматриваются и изменяются главным образом путем размещения, преобразования и редактирования свойств содержащихся в нем действующих лиц. В редакторе Unreal каждый уровень сохраняется в виде отдельного файла .umap, поэтому вы иногда будете видеть их как карты.
* **World** - World содержит список уровней, которые загружаются. Он обрабатывает потоки уровней и порождение (*spawning*) динамических актеров.  
Прямое взаимодействие с миром необязательно, но оно помогает обеспечить конкретную точку отсчета в структуре игры (т.е. Прямое упоминание мира означает, что вы не говорите об уровнях, картах или игре).
* **GameModes** - Класс *GameMode* отвечает за установление правил игры, в которую играют. Правила могут включать, как игроки присоединяются к игре, может ли игра быть приостановлена, и переходы уровня, а также любое специфическое для игры поведение, такое как условия победы.  
Вы можете установить *GameMode* по умолчанию в настройках проекта, но можете переопределить его для каждого уровня. Независимо от того, как вы решили реализовать *GameMode*, на каждом уровне всегда присутствует только один *GameMode*. В многопользовательской игре *GameMode* существует только на сервере, и правила реплицируются (отправляются) каждому из подключенных клиентов.
* **GameStates** - *GameState* содержит информацию , которую вы хотите реплицировать к каждому клиенту в игре, или более просто это «The State of the Game'» для всех , кто связан (for everyone connected).  
Он часто содержит информацию об игровом счете, независимо от того, начался матч или нет, сколько искусственного интеллекта появилось в зависимости от количества игроков в мире, и другую информацию, специфичную для игры.  
Для игр с многопользовательским режимом существует один экземпляр *GameState* на компьютере каждого игрока, причем экземпляр сервера является авторитетным (или тот, от которого клиенты получают обновленную информацию).
* **PlayerStates** - *PlayerState* является состоянием участника игры, такими как человеческий игрок или бот, который имитирующий игроком. Неигровой ИИ, существующий как часть игрового мира, не имеет *PlayerState*.  
Примерные данные, которые будут уместны в *PlayerState*, включают имя или счет игрока, его текущий уровень или состояние здоровья, а также то, несут ли они в настоящее время флаг в игре *Capture the Flag*.  
В многопользовательских играх *PlayerStates* для всех игроков существуют на всех компьютерах (в отличие от *PlayerControllers*) и могут реплицировать данные с сервера на клиент для синхронизации данных.

## Tools and Editors

[[2]](#-материалы)
* **Level Editor** - это основной редактор, используемый для создания игровых уровней. Вообще говоря, именно здесь вы определяете игровое пространство для своей игры, добавляя различные типы актеров и геометрию, чертежи, каскадные системы частиц или что-либо еще, что вы хотите добавить на свой уровень. По умолчанию, когда вы создаете или открываете проект, он открывается в редакторе уровней.
* **Material Editor** - это место, где вы можете создавать (или редактировать существующие) материалы, которые являются активами, которые можно применять к сетке для контроля ее визуального вида. Например, вы можете создать «грязный» материал и применить его к полам на вашем уровне или местности, чтобы создать грязь, выглядящую как поверхность.
* **Blueprint Editor** - это место, где вы можете работать и изменять *Blueprints*, которые являются специальными активами, которые можно использовать для создания новых типов *Actors* и событий уровня сценария, без необходимости писать какую-либо форму кода C++.
* **Behavior Tree Editor** - В редакторе дерева поведения вы можете создавать сценарии искусственного интеллекта с помощью визуальной системы на основе узлов (аналогично чертежам) для актеров на ваших уровнях (это может быть любое количество различных поведений для врагов, персонажей NPC, транспортных средств и т. Д.)
* **Persona Editor** - это набор инструментов для редактирования анимации в Unreal Engine 4, который используется для редактирования скелетных активов , скелетных сеток , анимационных чертежей и различных других анимационных активов. Большая часть (если не все) вашей анимационной работы в Unreal Engine 4 будет происходить в этом редакторе.
* **Cascade Editor** - Каскадные системы частиц в Unreal Engine 4 редактируются в Каскадном редакторе, который является полностью интегрированным и модульным редактором эффектов частиц. *Cascade* предлагает обратную связь в режиме реального времени и редактирование модульных эффектов, что позволяет быстро и легко создавать даже самые сложные эффекты.
* **UMG UI Editor** - это визуальный инструмент для создания пользовательского интерфейса, который можно использовать для создания таких элементов пользовательского интерфейса, как игровые *HUD*, меню или другая графика, связанная с интерфейсом, которую вы хотите представить своим пользователям.
* **Matinee Editor** - Matinee Editor основан на использовании специализированных анимационных дорожек, в которых вы можете размещать ключевые кадры, чтобы установить значения определенных свойств Актеров на вашем уровне. Это позволяет создавать внутриигровые кинематографические, динамические игровые события или даже анимировать свойства актеров с течением времени (например, управлять яркостью света).
* **Sound Cue Editor** - Поведение воспроизведения звука в Unreal Engine 4 определяется в Sound Cues, которые можно редактировать с помощью редактора *Sound Cue*. В редакторе *Sound Cue* вы можете комбинировать и микшировать несколько звуковых ресурсов, чтобы создать один смешанный «выход», сохраненный как *Sound Cue*.
* **Paper2D Sprite Editor** - Редактор спрайтов *Paper2D* позволяет настраивать и редактировать отдельные спрайты *Paper 2D* (которые по сути являются быстрым и простым способом рисования 2D-изображений в Unreal Engine 4).
* **Paper2D Flipbook Editor** - С помощью Paper2D Flipbook Editor вы можете создавать 2D анимацию, которая называется *Flipbooks*. Задав ряд спрайтов вдоль определенных ключевых кадров в редакторе бумажных карт *Paper2D*, эти кадры затем «пролистывают», чтобы создать анимацию. Лучший способ думать о *Flipbooks* - это старый рисованный стиль анимации.
* **Physics Asset Tool Editor** - Инструмент *Physics Asset Tool* (или *PhAT* для краткости) используется для создания физических активов для использования со скелетными сетками . Вы можете начать с нуля и перейти к полной установке *ragdoll* или использовать инструменты автоматизации для создания базового набора физических тел и физических ограничений.
* **Static Mesh Editor** - Редактор статических сеток используется для предварительного просмотра внешнего вида, столкновений и ультрафиолетовых лучей, а также для настройки и управления свойствами статических сеток . Внутри *Static Mesh Editor* вы также можете настроить *LOD* (или уровень детализации) для ваших активов *Static Mesh*.
* **Media Player Editor** - Редактор медиапроигрывателя позволяет определять мультимедийные файлы или URL-адреса для использования в качестве исходного мультимедиа для воспроизведения в Unreal Engine 4.  
Хотя это и не обязательно «Редактор», поскольку вы не можете редактировать мультимедийные файлы в этом Редакторе, вы определяете настройки того, как ваши исходные медиафайлы будут воспроизводиться, такие как, например, автоматическое воспроизведение, скорость воспроизведения или зацикливание.  
Вы также можете просматривать информацию о ваших медиа в этом редакторе, а также использовать стандартные элементы управления воспроизведением для просмотра медиа.



## Need more info...

...

## Материалы

1. [https://docs.unrealengine.com/en-US/GettingStarted/Terminology/index.html](https://docs.unrealengine.com/en-US/GettingStarted/Terminology/index.html)
2. [https://docs.unrealengine.com/en-US/GettingStarted/SubEditors/index.html](https://docs.unrealengine.com/en-US/GettingStarted/SubEditors/index.html)
